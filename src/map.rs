//! `World` iterators

use crate::{Entity, TryMut, TryRef};

/// An index wrapper for only immutable references
pub trait Index<C> {
    /// The type of the component's value
    type Output;
    /// Try to get a reference from an `Entity`
    fn try_entity(entity: &Entity<C>) -> Option<&Self::Output>;
}

impl<T, C> Index<C> for T
where
    T: Default,
    Entity<C>: TryRef<T>,
{
    type Output = <Entity<C> as TryRef<T>>::Output;
    fn try_entity(entity: &Entity<C>) -> Option<&Self::Output> {
        entity.try_ref(T::default())
    }
}

/// An index wrapper that designates a reference type
pub trait IndexMut<'a, C> {
    /// The reference to the component's value
    type Reference;
    /// Try to get a reference from an `Entity`
    fn try_entity_mut(entity: &'a Entity<C>) -> Option<Self::Reference>;
}

impl<'a, T, C> IndexMut<'a, C> for T
where
    T: Default,
    Entity<C>: TryMut<T>,
    <Entity<C> as TryRef<T>>::Output: 'a,
{
    type Reference = &'a mut <Entity<C> as TryRef<T>>::Output;
    fn try_entity_mut(entity: &'a Entity<C>) -> Option<Self::Reference> {
        unsafe { (entity as *const Entity<C> as *mut Entity<C>).as_mut() }
            .unwrap()
            .try_mut(T::default())
    }
}

/**
Creates a closure that filters a tuple of immutable
references to the specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.
*/
#[macro_export]
macro_rules! map {
    ($name:ident) => {
        |entity| $name::try_entity(entity)
    };
    ($($name:ident),*) => {
        |entity| if $($name::try_entity(entity).is_some() &&)* true {
            Some(($($name::try_entity(entity).unwrap()),*))
        } else {
            None
        }
    };
}

/**
Creates a closure that filters a tuple of mutable references to the
specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.

# Warning

It is considered undefined behavior to pass this macro multiple
reference specifiers of the same component,
i.e. `map_mut!(Foo, Foo)`.
While this violates Rust's borrowing rules, it will still
compile for reasons having to do with performance. If you want
runtime checks that no two components are the same, use
`map_mut_checked!`.
*/
#[macro_export]
macro_rules! map_mut {
    ($name:ident) => {
        |entity| $name::try_entity_mut(entity)
    };
    ($($name:ident),*) => {
        |entity| if $(map_mut!($name)(entity).is_some() &&)* true {
            Some(($(map_mut!($name)(entity).unwrap()),*))
        } else {
            None
        }
    };
}

/**
Creates a closure that filters a tuple of mutable references to the
specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.

Note that, because the generated closure performs a uniqueness check,
it will likely be considerably slower than one generated by `map_mut!`.

# Panics

Panics if any two components specifiers are the same,
i.e. `map_mut_checked!(Foo, Foo)`.
*/
#[macro_export]
macro_rules! map_mut_checked {
    ($name:ident) => {
        |entity| $name::try_entity_mut(entity)
    };
    ($($name:ident),*) => {
        |entity| {
            use std::collections::HashSet;
            let mut used: HashSet<String> = HashSet::new();
            $(
                let s = format!("{:?}", $name::default());
                if !used.contains(&s) {
                    used.insert(s);
                } else {
                    panic!("{:?} is used twice in `map_mut_checked` in {} on line {}:{}", s, file!(), line!(), column!());
                }
            )*
            if $(map_mut_checked!($name)(entity).is_some() &&)* true {
                Some(($(map_mut_checked!($name)(entity).unwrap()),*))
            } else {
                None
            }
        }
    };
}

/**
Creates a closure that returns whether or not an `Entity`
contains all spcified components.
*/
#[macro_export]
macro_rules! tags {
    ($name:ident) => {
        |entity| $name::try_entity(entity).is_some()
    };
    ($($name:ident),*) => {
        |entity| $($name::try_entity(entity).is_some() &&)* true
    };
}
