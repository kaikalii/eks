//! `World` iterators

use crate::{Entity, TryMut, TryRef};

/// An index wrapper that designates an immutable reference
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct Ref<T>(pub T);

/// An index wrapper that designates a mutable reference
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct Mut<T>(pub T);

/// An index wrapper for only immutable references
pub trait Index<C> {
    /// The type of the component's value
    type Output;
    /// Try to get a reference from an `Entity`
    fn try_entity(self, entity: &Entity<C>) -> Option<&Self::Output>;
}

impl<T, C> Index<C> for Ref<T>
where
    Entity<C>: TryRef<T>,
{
    type Output = <Entity<C> as TryRef<T>>::Output;
    fn try_entity(self, entity: &Entity<C>) -> Option<&Self::Output> {
        entity.try_ref(self.0)
    }
}

impl<T, C> Index<C> for T
where
    Entity<C>: TryRef<T>,
{
    type Output = <Entity<C> as TryRef<T>>::Output;
    fn try_entity(self, entity: &Entity<C>) -> Option<&Self::Output> {
        entity.try_ref(self)
    }
}

/// An index wrapper that designates a reference type
pub trait IndexMut<'a, C> {
    /// The reference to the component's value
    type Reference;
    /// The inner type
    type Inner;
    /// Try to get a reference from an `Entity`
    fn try_entity_mut(self, entity: &'a Entity<C>) -> Option<Self::Reference>;
    /// Get the inner value
    fn inner(&self) -> &Self::Inner;
}

impl<'a, T, C> IndexMut<'a, C> for Ref<T>
where
    Entity<C>: TryRef<T>,
    <Entity<C> as TryRef<T>>::Output: 'a,
{
    type Reference = &'a <Entity<C> as TryRef<T>>::Output;
    type Inner = T;
    fn try_entity_mut(self, entity: &'a Entity<C>) -> Option<Self::Reference> {
        entity.try_ref(self.0)
    }
    fn inner(&self) -> &Self::Inner {
        &self.0
    }
}

impl<'a, T, C> IndexMut<'a, C> for T
where
    Entity<C>: TryRef<T>,
    <Entity<C> as TryRef<T>>::Output: 'a,
{
    type Reference = &'a <Entity<C> as TryRef<T>>::Output;
    type Inner = T;
    fn try_entity_mut(self, entity: &'a Entity<C>) -> Option<Self::Reference> {
        entity.try_ref(self)
    }
    fn inner(&self) -> &Self::Inner {
        self
    }
}

impl<'a, T, C> IndexMut<'a, C> for Mut<T>
where
    Entity<C>: TryMut<T>,
    <Entity<C> as TryRef<T>>::Output: 'a,
{
    type Reference = &'a mut <Entity<C> as TryRef<T>>::Output;
    type Inner = T;
    fn try_entity_mut(self, entity: &'a Entity<C>) -> Option<Self::Reference> {
        unsafe {
            (entity as *const Entity<C> as *mut Entity<C>)
                .as_mut()
                .unwrap()
        }
        .try_mut(self.0)
    }
    fn inner(&self) -> &Self::Inner {
        &self.0
    }
}

/**
Creates a closure that filters a tuple of immutable
references to the specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.
*/
#[macro_export]
macro_rules! map {
    ($name:expr) => {
        |entity: & Entity<_>| $name.try_entity(entity)
    };
    ($($name:expr),*) => {
        |entity: & Entity<_>| if $($name.try_entity(entity).is_some() &&)* true {
            Some(($($name.try_entity(entity).unwrap()),*))
        } else {
            None
        }
    };
}

/**
Creates a closure that filters a tuple of references to the
specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.

# Warning

It is considered undefined behavior to pass this macro multiple
reference specifiers of the same component,
i.e. `map_mut!(Foo::as_mut(), Foo::as_ref())`.
While this violates Rust's borrowing rules, it will still
compile for reasons having to do with performance. If you want
runtime checks that no two components are the same, use
`map_mut_checked!`.
*/
#[macro_export]
macro_rules! map_mut {
    ($name:expr) => {
        |entity: &mut Entity<_>| $name.try_entity_mut(entity)
    };
    ($($name:expr),*) => {
        |entity: &mut Entity<_>| if $($name.try_entity_mut(entity).is_some() &&)* true {
            Some(($($name.try_entity_mut(entity).unwrap()),*))
        } else {
            None
        }
    };
}

/**
Creates a closure that filters a tuple of references to the
specified components from an `Entity`.

If only one component is specified, the optional return value
will not be a tuple.

Note that, because the generated closure performs a uniqueness check,
it will likely be considerably slower than one generated by `map_mut!`.

# Panics

Panics if any two components specifiers are the same,
i.e. `map_mut_checked!(Foo::as_mut(), Foo::as_ref())`.
*/
#[macro_export]
macro_rules! map_mut_checked {
    ($name:expr) => {
        |entity: &mut Entity<_>| $name.try_entity_mut(entity)
    };
    ($($name:expr),*) => {
        |entity: &mut Entity<_>| {
            use std::collections::HashSet;
            let mut used: HashSet<String> = HashSet::new();
            $(
                let s = format!("{:?}", $name.inner());
                if !used.contains(&s) {
                    used.insert(s);
                } else {
                    panic!("{:?} is used twice in `map_mut_checked` in {} on line {}:{}", s, file!(), line!(), column!());
                }
            )*
            if $($name.try_entity_mut(entity).is_some() &&)* true {
                Some(($($name.try_entity_mut(entity).unwrap()),*))
            } else {
                None
            }
        }
    };
}
